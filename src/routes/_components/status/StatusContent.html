<div class={computedClass} ref:node>
    {@html massagedContent}
    {#await shouldTranslate}
      <!-- waiting -->
    {:then answer}
      {#if answer}
	      <div>this post is probably not english</div>
      {/if}
    {:catch error}
	    <!-- {error} -->
    {/await}
</div>
<style>
  .status-content {
    margin: 10px 10px 10px 5px;
    grid-area: content;
    word-wrap: break-word;
    overflow: hidden;
    white-space: pre-wrap;
    font-size: 1.17em;
    display: none;
  }

  .status-content.status-in-own-thread {
    font-size: 1.69em;
    margin: 20px 10px 20px 5px;
  }

  .status-content.shown {
    display: block;
  }

  :global(
      .status-content p,
      .status-content blockquote,
      .status-content ul,
      .status-content ol) {
    margin: 0 0 20px;
  }

  :global(
      .status-content p:first-child,
      .status-content blockquote:first-child,
      .status-content ul:first-child,
      .status-content ol:first-child) {
    margin: 0 0 20px;
  }

  :global(
      .status-content p:last-child,
      .status-content blockquote:last-child,
      .status-content ul:last-child,
      .status-content ol:last-child) {
    margin: 0;
  }

  :global(.status-content blockquote) {
    padding-left: 1.5rem;
    border-left: 5px solid var(--body-bg);
    /*color: var(--very-deemphasized-text-color);
    font-style: italic;*/
  }

  :global(.status-content ul, .status-content ol) {
    padding-left: 2rem;
  }

  .status-content.status-in-notification {
    color: var(--very-deemphasized-text-color);
  }
  :global(.status-content.status-in-notification a, .status-content.status-in-notification a:hover) {
    color: var(--very-deemphasized-link-color);
  }

  :global(.underline-links .status-content a) {
    text-decoration: underline;
  }

  @media (max-width: 240px) {
    :global(
      .status-content p:last-child,
      .status-content blockquote:last-child,
      .status-content ul:last-child,
      .status-content ol:last-child) {
      margin: 0 0 10px; /* looks better on KaiOS with some spacing here */
    }
  }

</style>
<script>
  import { mark, stop } from '../../_utils/marks.js'
  import { store } from '../../_store/store.js'
  import { classname } from '../../_utils/classname.js'
  import { massageUserText } from '../../_utils/massageUserText.js'
  import { urlIsCrossOrigin } from '../../_utils/urlIsCrossOrigin.js'
  import { importConfetti } from '../../_utils/asyncModules/importConfetti.js'
  import { importGoogleTranslate } from '../../_utils/asyncModules/importGoogleTranslate.js'
  import { franc } from '../../_utils/franc.js'

  async function translate(html, to, from) {
    return await (
      await importGoogleTranslate()
    )(html, to, from);
  }
  if (process.browser) {
    window.__translate = translate;
    window.__franc = franc;
  }

  export default {
    oncreate () {
      this.hydrateContent()
    },
    store: () => store,
    computed: {
      computedClass: ({ isStatusInOwnThread, isStatusInNotification, shown }) => {
        return classname(
          'status-content',
          isStatusInOwnThread && 'status-in-own-thread',
          isStatusInNotification && 'status-in-notification',
          shown && 'shown'
        )
      },
      content: ({ originalStatus }) => (originalStatus.content || ''),
      massagedContent: ({ content, originalStatusEmojis, $autoplayGifs }) => (
        massageUserText(content, originalStatusEmojis, $autoplayGifs)
      ),
      shouldTranslate: async ({ plainTextContent, $detectTranslation }) => {
        if(!$detectTranslation) return false
        const strippedText = plainTextContent.replace(/:\w+:|\w+:\/\/\S+|#\w+/g,"")
        const francResult = await franc(strippedText)
        if(francResult) {
          const eng = francResult.find(e=>e[0]=='eng')
          if(eng) return (eng[1]+Math.max((strippedText.length*-0.01)+0.2, 0))<0.6 // ehh, not great, but it'll do
          return true
        } else {
          return false
        }
      }
    },
    methods: {
      hydrateContent () {
        mark('hydrateContent')
        const node = this.refs.node
        const { originalStatus, uuid } = this.get()
        const { mentions, tags } = originalStatus
        let count = 0
        const anchors = Array.from(node.getElementsByTagName('A'))

        for (const anchor of anchors) {
          // hydrate hashtag
          if (tags && anchor.classList.contains('hashtag')) {
            for (const tag of tags) {
              if (anchor.getAttribute('href').toLowerCase().endsWith(`/${tag.name.toLowerCase()}`)) {
                anchor.setAttribute('href', `/tags/${tag.name}`)
                anchor.setAttribute('id', `status-content-link-${uuid}-${++count}`)
                anchor.removeAttribute('target')
                anchor.removeAttribute('rel')
              }
            }
          // hydrate mention
          } else if (mentions && anchor.classList.contains('mention')) {
            for (const mention of mentions) {
              if (anchor.getAttribute('href') === mention.url) {
                anchor.setAttribute('href', `/accounts/${mention.id}`)
                anchor.setAttribute('title', `@${mention.acct}`)
                anchor.setAttribute('id', `status-content-link-${uuid}-${++count}`)
                anchor.removeAttribute('target')
                anchor.removeAttribute('rel')
              }
            }
          }
          // hydrate external links
          const href = anchor.getAttribute('href')
          const hrefParsed = new URL(href, location.href);
          const match = hrefParsed.href.match(/^https?:\/\/(?:[^\/]+?\.)?(?:twitter\.com|nitter\.[^\/]+)(?:\/(.*))?$/);
          if(match) {
            anchor.setAttribute('href', `/nitter/${encodeURIComponent(match[1]||"")}`)
            anchor.setAttribute('target', '_blank')
            anchor.setAttribute('rel', 'nofollow noopener')
          } else if (hrefParsed.hostname.startsWith("pinafore") && hrefParsed.pathname=="/confetti") {
            anchor.setAttribute('title', "confetti!")
            anchor.setAttribute('target', '_self')
            anchor.setAttribute('href', "/confetti")
            anchor.addEventListener("click", function (e) {
              e.preventDefault();
              importConfetti().then(confetti=>confetti())
            })
          } if (urlIsCrossOrigin(href)) {
            anchor.setAttribute('title', href)
            anchor.setAttribute('target', '_blank')
            anchor.setAttribute('rel', 'nofollow noopener')
          }
        }
        stop('hydrateContent')
      }
    }
  }
</script>
